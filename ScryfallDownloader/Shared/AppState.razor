@inject ScryfallApiClient Api
@inject CardDownloaderService Downloader
@inject IOService IO
@inject ImageService Image
@inject ForgeService Forge
@inject DataService DB
@inject StarCityGamesScraper SCG
@inject MoxfieldDownloaderService Moxfield
@inject MtgTop8DownloaderService MT8

<CascadingValue Value="@this">
    <CascadingValue Value="@state">
        @ChildContent
    </CascadingValue>
</CascadingValue>

@code {
    [Parameter]
    public RenderFragment ChildContent { get; set; }

    public DownloadSettingsModel DownloadSettings { get; set; } = new();
    public ForgeDataModel ForgeData { get; set; } = new();
    public List<ScryfallApi.Client.Models.Set> AllSets { get; set; } = new();
    public string SetFilter { get; set; } = "";

    private List<SCGDeckModel> _scgDecks = new();

    private Dictionary<string, List<string>> _duplicatePrints = new();
    private string _currentSet;
    private DownloadStates state = new();

    protected override async Task OnInitializedAsync()
    {
        DownloadSettings.ImagesPath = @"E:\Jogos\Magic the Gathering\Forge\data\cache\pics\cards";
        DownloadSettings.EditionsPath = @"E:\Jogos\Magic the Gathering\Forge\res\editions";
        Forge.SetPaths(DownloadSettings.ImagesPath, DownloadSettings.EditionsPath);

        await Forge.GetCardsData();
        await GetAllSets();
        await AuditSets();
    }

    private async Task GetAllSets()
    {
        var result = await Api.Sets.Get();
        AllSets = new List<ScryfallApi.Client.Models.Set>(result.Data);
    }

    public async Task AuditSets()
    {
        if (AllSets == null) await GetAllSets();

        await Forge.AuditSets(ForgeData, AllSets);
    }

    public async Task AuditCards(string code)
    {
        await Forge.AuditCards(ForgeData, code, DownloadSettings.RedownloadData, DownloadSettings.IgnoreFoil, DownloadSettings.IgnoreVariations, DownloadSettings.IgnoreNonEnglish);
    }

    public void RemoveAuditedSet(string code)
    {
        if (ForgeData.ImplementedCards.Count == 0 && ForgeData.MissingCards.Count == 0) return;

        if (ForgeData.ImplementedCards.Count > 0)
            ForgeData.ImplementedCards = ForgeData.ImplementedCards.Where(c => c.Set != code).ToList();

        if (ForgeData.MissingCards.Count > 0)
            ForgeData.MissingCards = ForgeData.MissingCards.Where(c => c.Set != code).ToList();
    }

    private List<string> _multiFacedLayouts = new List<string>() { "transform", "modal_dfc", "reversible_card", "flip" };

    public async Task DownloadImages()
    {
        DownloadSettings.Cards = ForgeData.ImplementedCards;
        if (DownloadSettings.DownloadMissing) DownloadSettings.Cards.AddRange(ForgeData.MissingCards);

        state.CurrentCard = 0;
        state.TotalCards = DownloadSettings.Cards.Count();
        state.IsDownloading = true;

        _currentSet = DownloadSettings.Cards[0].Set;
        var setPath = CheckDirectory(_currentSet);

        foreach (var card in DownloadSettings.Cards)
        {
            state.CurrentCardName = $"{card.Name} | {card.Set.ToUpper()}";
            state.CurrentCard++;

            if (_currentSet != card.Set) setPath = CheckDirectory(card.Set);

            var saveFormat = ParseFormat();

            if (_multiFacedLayouts.Contains(card.Layout) && card.CardFaces != null)
            {
                foreach (var face in card.CardFaces)
                {
                    var cardPath = Path.Combine(setPath, $"{ParseCardName(card, face)}.full.{saveFormat}");
                    Dictionary<string, Uri> imageUris;

                    // Flip cards have 2 card faces for each orientation but only 1 imageuris list
                    // We need to use the card.ImageUris instead and also re-save and rotate the image for the second face
                    var rotate = false;
                    if (card.Layout == "flip")
                    {
                        imageUris = card.ImageUris;
                        if (card.CardFaces[1] == face) rotate = true;
                    }
                    else
                        imageUris = face.ImageUris;

                    if (DownloadSettings.InstantDownload)
                        SaveImage(imageUris, cardPath, card.HighresImage, rotate);
                    else
                        await SaveImage(imageUris, cardPath, card.HighresImage, rotate);
                }
            }
            else
            {
                var cardPath = Path.Combine(setPath, $"{ParseCardName(card)}.full.{saveFormat}");

                if (DownloadSettings.InstantDownload)
                    SaveImage(card.ImageUris, cardPath, card.HighresImage);
                else
                    await SaveImage(card.ImageUris, cardPath, card.HighresImage);
            }
        }

        state.IsDownloading = false;
        _duplicatePrints.Clear();
        DownloadSettings.Cards.Clear();
        ForgeData.ImplementedCards.Clear();
        ForgeData.MissingCards.Clear();
    }

    private async Task SaveImage(Dictionary<string, Uri> uris, string path, bool highres, bool rotate = false)
    {
        if (File.Exists(path) && DownloadSettings.IgnoreExisting) return;

        var format = DownloadSettings.PngHighresOnly && DownloadSettings.Format == "png" && !highres ? "border_crop" : DownloadSettings.Format;
        if (uris == null || uris[format] == null) return;

        var data = await Downloader.DownloadImage(uris[format].AbsoluteUri);

        if (DownloadSettings.ConvertToJpg && format == "png") data = Image.ConvertToJpg(data, DownloadSettings.OutputQuality);

        if (rotate) data = Image.Rotate180(data);

        await IO.SaveFile(path, data);
    }

    private string CheckDirectory(string scryfallSet)
    {
        // TODO: Get appropriate Set code directory for the rare cases where multiple Forge editions match to a single Scryfall set (MED and TD0).
        var set = ForgeData.MatchedSets.FirstOrDefault(s => s.ScryfallCode == scryfallSet, null);

        // Null MatchedSet means it's unimplemented in Forge,
        // Using the argument's code to create a directory following Scryfall we can download the cards anyway,
        // This is useful for token like cards (eg. Archenemy Schemes or AFR Dungeons).
        var code = set != null ? set.ForgeCode : scryfallSet;

        var path = Path.Combine(DownloadSettings.ImagesPath, code);

        if (Directory.Exists(path) && DownloadSettings.RemoveExisting)
            Directory.Delete(path, true);

        IO.CreateDirectory(path);

        _currentSet = scryfallSet;

        return path;
    }

    private string ParseFormat() => (DownloadSettings.Format != "png" || DownloadSettings.ConvertToJpg) ? "jpg" : "png";

    private string ParseCardName(ScryfallApi.Client.Models.Card card, CardFace? face = null)
    {
        var cardName = face == null ? card.Name : face.Name;

        // Adventure layout cards will include both faces names separated by " // ",
        // Forge will only use the first face's name, the text written on the top of the card.
        if (card.Layout == "adventure" && cardName.Contains(" // ")) cardName = cardName.Split(" // ")[0];

        if (DownloadSettings.Cards.Count(c => c.Name == card.Name && c.Set == card.Set) > 1)
        {
            if (!_duplicatePrints.ContainsKey(card.Set)) _duplicatePrints.Add(card.Set, new List<string>());

            _duplicatePrints[card.Set].Add(cardName);

            var count = _duplicatePrints[card.Set].Count(c => c == cardName);

            cardName = cardName + count;
        }

        return cardName.ParseCardname(true);
    }

    public async Task InitializeDatabase()
    {
        var setIndex = 0;
        foreach (var set in AllSets.OrderBy(s => s.ReleaseDate).ToList())
        {
            setIndex++;
            Console.WriteLine($"\n\nCreating Set {setIndex}/{AllSets.Count}: {set.Code.ToUpper()} | {set.Name}\n");

            if (await DB.GetSet(set.Code) != null) continue;

            var setEntity = new Data.Set();

            setEntity.Name = set.Name;
            setEntity.Code = set.Code;

            var forgeSet = ForgeData.MatchedSets.FirstOrDefault(s => s.ScryfallCode == set.Code, null);
            if (forgeSet != null) setEntity.ForgeCode = forgeSet.ForgeCode;

            if (set.ReleaseDate != null) setEntity.ReleaseDate = DateOnly.FromDateTime((DateTime)set.ReleaseDate);

            var setType = await DB.GetSetType(set.SetType);
            if (setType == null) setEntity.SetType = new Data.SetType() { Name = set.SetType };
            else setEntity.SetType = setType;

            var createdSetEntity = await DB.Create(setEntity);

            if (Forge.Cards.Count > 0)
            {
                var setCards = Forge.Cards.Where(c => c.Set == set.Code);
                var cardTotal = setCards.Count();
                var cardIndex = 0;
                foreach (var card in setCards)
                {
                    cardIndex++;
                    Console.WriteLine($"{setIndex}||{cardIndex}/{cardTotal}: {card.Name}");

                    var cardEntity = new Data.Card();

                    cardEntity.Name = card.Name;
                    cardEntity.CollectorsNumber = card.CollectorNumber;

                    if (!string.IsNullOrWhiteSpace(card.Rarity))
                        cardEntity.Rarity = new Rarity() { Name = card.Rarity, Symbol = card.Rarity.ToUpper()[0] };

                    cardEntity.Artist = new Artist() { Name = card.Artist };
                    cardEntity.Set = createdSetEntity;
                    cardEntity.IsImplemented = CheckForgeImplementation(card.Name);

                    var createdCardEntity = await DB.Create(cardEntity);
                    await DB.AddCardToSet(createdSetEntity.SetId, createdCardEntity.CardId);
                }
            }
        }
    }

    public async Task GetMtgTop8Decks()
    {
        var currentPage = 110;
        do
        {
            var decks = await MT8.GetDecks(currentPage);
            if (decks == null) break;

            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine($"=========================================================Page: {currentPage}");
            Console.ResetColor();
            await CreateDeckRecords(decks, "MTGTop8", "https://mtgtop8.com/");

            currentPage++;
        } while (true);

        Console.WriteLine("Deck Scraping Has Finished!");
    }

    public async Task GetScgDecks()
    {
        var startingUrl = "https://old.starcitygames.com/decks/results/formats_all/All/start_date/01-01-1970/end_date/22-01-2023/order_1/date%20desc/order_2/finish/limit/20/start_num/16300/";

        var currentPage = 816;
        var nextUrl = string.Empty;
        do
        {
            var response = await SCG.GetDecks(currentPage == 816 ? startingUrl : nextUrl, currentPage);
            if (response == null) break;

            nextUrl = response.Value.Item1;
            var decks = response.Value.Item2;

            Console.WriteLine($"\n\nPage {currentPage}: Decks {_scgDecks.Count}");
            currentPage++;

            await CreateDeckRecords(decks, "StarCityGames", "https://old.starcitygames.com/decks/");
            //} while (currentPage < 2);
        } while (!string.IsNullOrWhiteSpace(nextUrl));

        Console.WriteLine("Deck Scraping Has Finished!");

        //var json = JsonSerializer.Serialize<List<SCGDeckModel>>(_scgDecks, new JsonSerializerOptions() { WriteIndented = true });
        //await IO.SaveTextFile("scgDecks.json", json);
    }

    public async Task CreateDeckRecords(List<SCGDeckModel> decks, string sourceName, string sourceLink)
    {
        var deckIndex = 0;
        foreach (var deck in decks)
        {
            deckIndex++;
            if (await DB.CheckDeckExists(deck.Name, deck.Player, deck.Date)) continue;

            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine($"{deckIndex}/{decks.Count}||{deck.Name} - {deck.Player} - {deck.Link.PathAndQuery}");
            Console.ResetColor();

            var deckEntity = new Data.Deck();
            deckEntity.Name = deck.Name;
            deckEntity.Description = deck.Description;
            deckEntity.CreateDate = deck.Date;
            deckEntity.UpdateDate = DateTime.Now;
            deckEntity.Author = new Data.Author() { Name = deck.Player };
            deckEntity.Format = new Data.Format() { Name = deck.Format.ToLower() };
            deckEntity.Source = new Data.Source() { Name = sourceName, Url = new Uri(sourceLink) };

            var createdDeckEntity = await DB.Create(deckEntity);

            var cardIndex = 0;
            foreach (var card in deck.Cards)
            {
                cardIndex++;
                if (card.IsSideboard)
                    Console.ForegroundColor = ConsoleColor.DarkCyan;
                Console.WriteLine($"{deckIndex}||{cardIndex}/{deck.Cards.Count}: {card.Name}");
                Console.ResetColor();

                // Try getting the latest print before deck creation date, get the latest version of the card otherwise.
                var cardEntity = await DB.GetCard(card.Name, DateOnly.FromDateTime(deck.Date));
                if (cardEntity == null) cardEntity = await DB.GetCard(card.Name);

                if (cardEntity != null) await DB.AddCardToDeck(createdDeckEntity.DeckId, cardEntity.CardId, card.Quantity, card.IsSideboard);
                else
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine($"----CARD NOT FOUND: {card.Name}");
                    Console.ResetColor();
                    if (deckEntity.MissingCards == null) deckEntity.MissingCards = new List<string>() { card.Name };
                    else deckEntity.MissingCards.Add(card.Name);
                }
            }
            if (deckEntity.MissingCards != null) { var updatedDeck = await DB.UpdateDeckMissingCards(deckEntity.DeckId, deckEntity.MissingCards); }
        }
    }

    public async Task GetMoxfieldDecks()
    {
        //List<string> formats = new() { "alchemy", "archon", "brawl", "centurion", "conquest", "duelCommander", "explorer", "gladiator", "highlanderAustralian", "highlanderCanadian", "highlanderEuropean", "historic", "historicBrawl", "legacy", "leviathan", "oldSchool", "oathbreaker", "pauper", "pauperEdh", "pennyDreadful", "pioneer", "premodern", "primordial", "tinyLeaders", "vintage", "standard", "modern", "commander", "none" };
        List<string> formats = new() { "none" };

        List<string> formatsPrecons = new() { "precons", "commanderPrecons" };

        foreach (var format in formats)
        {
            Console.WriteLine($"\n\n::: {format.ToUpper()} :::\n\n");
            var decks = await Moxfield.GetDecks(format, "views", true);
            var json = JsonSerializer.Serialize<List<MoxfieldDeckModel>>(decks, new JsonSerializerOptions() { WriteIndented = true });
            await IO.SaveTextFile($"moxfield_{format}.json", json);
        }
    }

    public void CreateMoxfieldDeckRecordsFromJson(string jsonPath)
    {
        var decks = IO.GetMoxfieldDecks(jsonPath);
        var deckIndex = 0;
        foreach (var deck in decks)
        {
            deckIndex++;
            if (DB.CheckDeckExists(deck.Name, deck.CreatedAt)) continue;
            Console.WriteLine($"\n\nCreating Deck {deckIndex}/{decks.Count}: {deck.Name}\n");

            var deckEntity = new Data.Deck();
            deckEntity.Name = deck.Name;
            deckEntity.Description = $"PublicID: {deck.PublicId}";
            deckEntity.CreateDate = deck.CreatedAt;
            deckEntity.UpdateDate = deck.UpdatedAt;
            deckEntity.ViewCount = deck.Views;
            deckEntity.LikeCount = deck.Likes;
            deckEntity.CommentCount = deck.Comments;
            deckEntity.Author = new Data.Author() { Name = deck.Author };
            deckEntity.Format = new Data.Format() { Name = deck.Format.ToLower() };
            deckEntity.Source = new Data.Source() { Name = "Moxfield", Url = new Uri("https://www.moxfield.com/") };

            if (deck.Hubs != null)
            {
                var tagList = new List<Data.Tag>();
                foreach (var hub in deck.Hubs)
                {
                    var tag = new Data.Tag() { Name = hub.Name, Description = hub.Description };
                    tagList.Add(tag);
                }
                deckEntity.Tags = tagList;
            }

            if (deck.Commanders != null)
            {
                var card = DB.GetCard(deck.Commanders[0].Name);
                deckEntity.Commander = card;
            }

            var createdDeckEntity = DB.Create(deckEntity);

            var cardIndex = 0;
            Console.WriteLine("\nMainboard:");

            if (deck.Mainboard != null)
            {
                foreach (var card in deck.Mainboard)
                {
                    cardIndex++;
                    Console.WriteLine($"{deckIndex}||{cardIndex}/{deck.Mainboard.Count}: {card.Name}");

                    var cardEntity = DB.GetCard(card.Name, card.Set);

                    if (cardEntity != null)
                        DB.AddCardToDeck(createdDeckEntity.DeckId, cardEntity.CardId, card.Quantity, false);
                    else
                        Console.WriteLine($"----CARD NOT FOUND: {card.Name} | {card.Set}");
                }
            }

            if (deck.Sideboard != null)
            {
                cardIndex = 0;
                Console.WriteLine("\nSideboard:");

                foreach (var card in deck.Sideboard)
                {
                    cardIndex++;
                    Console.WriteLine($"{deckIndex}||{cardIndex}/{deck.Sideboard.Count}: {card.Name}");

                    var cardEntity = DB.GetCard(card.Name, card.Set);

                    if (cardEntity != null)
                        DB.AddCardToDeck(createdDeckEntity.DeckId, cardEntity.CardId, card.Quantity, true);
                    else
                        Console.WriteLine($"----CARD NOT FOUND: {card.Name} | {card.Set}");
                }
            }
        }
    }

    private bool CheckForgeImplementation(string cardName)
    {
        // Check for flip cards where both parts of the name are relevant but Forge ignores the separator characters (eg. Wear // Tear => WearTear)
        var isImplemented = ForgeData.Editions.Any(e => e.Cards.Any(c => c.Name.ParseCardname().Contains(cardName.ParseCardname())));

        // Check for double faced cards where only the first part of the name is relevant (eg. Thing in the Ice // Awoken Horror => Thing in the Ice)
        if (!isImplemented)
            isImplemented = ForgeData.Editions.Any(e => e.Cards.Any(c => c.Name.ParseSplitCardname().Contains(cardName.ParseSplitCardname())));

        return isImplemented;
    }

    public async Task RecheckCardImplementation()
    {
        var cards = await DB.GetUnimplementedCards();

        foreach (var card in cards)
        {
            var implementation = CheckForgeImplementation(card.Name);

            if (implementation != card.IsImplemented)
            {
                Console.WriteLine($"{card.Name}");
                await DB.UpdateCardImplementation(card.CardId, implementation);
            }
        }
    }
}

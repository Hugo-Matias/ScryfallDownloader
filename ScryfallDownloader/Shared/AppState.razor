@inject ScryfallApiClient Api
@inject DownloaderService Downloader
@inject IOService IO
@inject ImageService ImageService

<CascadingValue Value="@this">
    <CascadingValue Value="@state">
        @ChildContent
    </CascadingValue>
</CascadingValue>

@code {
    [Parameter]
    public RenderFragment ChildContent { get; set; }

    public List<Set> Sets { get; set; } = new();
    public DownloadSettingsModel DownloadSettings { get; set; } = new();

    private Dictionary<string, List<string>> _duplicatePrints = new();
    private string _currentSet;
    private DownloadStates state = new();

    protected override async Task OnInitializedAsync()
    {
        DownloadSettings.ImagesPath = @"E:\Jogos\Magic the Gathering\Forge\data\cache\pics\cards";
        await GetSets();
    }

    private async Task GetSets()
    {
        var result = await Api.Sets.Get();
        Sets = new List<Set>(result.Data);
    }

    public async Task GetCards()
    {
        if (DownloadSettings.Sets.Count <= 0) return;

        DownloadSettings.Cards.Clear();

        foreach (var set in DownloadSettings.Sets)
        {
            try
            {
                int page = 1;
                bool hasMore = false;
                do
                {
                    hasMore = await SearchCardsAndAppend(set, page);
                    page++;
                } while (hasMore == true);
            }
            catch (Exception e)
            {
                throw e;
            }
        }

        state.CurrentCard = 0;
        state.TotalCards = DownloadSettings.Cards.Count();
    }

    private async Task<bool> SearchCardsAndAppend(string set, int page)
    {
        try
        {
            SearchOptions options = new SearchOptions()
                {
                    Sort = SearchOptions.CardSort.Set,
                    Mode = SearchOptions.RollupMode.Prints
                };

            var cards = await Api.Cards.Search($"set:{set}", page, options);

            DownloadSettings.Cards.AddRange(cards.Data);

            return cards.HasMore;
        }
        catch (Exception e)
        {
            throw e;
        }
    }

    public async Task DownloadImages()
    {
        state.IsDownloading = true;

        _currentSet = DownloadSettings.Cards[0].Set;
        var setPath = CheckDirectory(_currentSet);

        foreach (var card in DownloadSettings.Cards)
        {
            state.CurrentCardName = $"{card.Name} | {card.Set.ToUpper()}";
            state.CurrentCard++;

            if (_currentSet != card.Set) setPath = CheckDirectory(card.Set);

            var saveFormat = ParseFormat();

            var cardPath = Path.Combine(setPath, $"{ParseCardName(card)}.full.{saveFormat}");

            if (File.Exists(cardPath) && DownloadSettings.IgnoreExisting) continue;

            await SaveImage(card, cardPath);
        }

        state.IsDownloading = false;
        _duplicatePrints.Clear();
    }

    private async Task SaveImage(Card card, string path)
    {
        var data = await Downloader.DownloadImage(card.ImageUris[DownloadSettings.Format].AbsoluteUri);

        if (DownloadSettings.ConvertToJpg && DownloadSettings.Format == "png")
            data = ImageService.ConvertToJpg(data, DownloadSettings.OutputQuality);

        await IO.SaveFile(path, data);
    }

    private string CheckDirectory(string set)
    {
        var path = Path.Combine(DownloadSettings.ImagesPath, set);

        if (Directory.Exists(path) && DownloadSettings.RemoveExisting)
            Directory.Delete(path, true);

        IO.CreateDirectory(path);

        _currentSet = set;

        return path;
    }

    private string ParseFormat() => (DownloadSettings.Format != "png" || DownloadSettings.ConvertToJpg) ? "jpg" : "png";

    private string ParseCardName(Card card)
    {
        if (DownloadSettings.Cards.Count(c => c.Name == card.Name && c.Set == card.Set) > 1)
        {
            if (!_duplicatePrints.ContainsKey(card.Set)) _duplicatePrints.Add(card.Set, new List<string>());

            _duplicatePrints[card.Set].Add(card.Name);

            var count = _duplicatePrints[card.Set].Count(c => c == card.Name);

            return card.Name + count;
        }

        return card.Name;
    }
}

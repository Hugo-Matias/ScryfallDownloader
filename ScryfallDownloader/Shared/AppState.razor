@inject ScryfallApiClient Api
@inject CardDownloaderService Downloader
@inject IOService IO
@inject ImageService Image
@inject ForgeService Forge

<CascadingValue Value="@this">
    <CascadingValue Value="@state">
        @ChildContent
    </CascadingValue>
</CascadingValue>

@code {
    [Parameter]
    public RenderFragment ChildContent { get; set; }

    public DownloadSettingsModel DownloadSettings { get; set; } = new();
    public ForgeDataModel ForgeData { get; set; } = new();
    public List<Set> AllSets { get; set; } = new();
    public string SetFilter { get; set; } = "";

    private Dictionary<string, List<string>> _duplicatePrints = new();
    private string _currentSet;
    private DownloadStates state = new();

    protected override async Task OnInitializedAsync()
    {
        DownloadSettings.ImagesPath = @"E:\Jogos\Magic the Gathering\Forge\data\cache\pics\cards";
        DownloadSettings.EditionsPath = @"E:\Jogos\Magic the Gathering\Forge\res\editions";
        Forge.SetPaths(DownloadSettings.ImagesPath, DownloadSettings.EditionsPath);

        await Forge.GetCardsData();
        await GetAllSets();
        await AuditSets();
    }

    private async Task GetAllSets()
    {
        var result = await Api.Sets.Get();
        AllSets = new List<Set>(result.Data);
    }

    public async Task GetCards()
    {
        if (DownloadSettings.Sets.Count == 0) return;

        DownloadSettings.Cards.Clear();

        foreach (var set in DownloadSettings.Sets)
        {
            try
            {
                int page = 1;
                bool hasMore = false;
                do
                {
                    hasMore = await SearchCardsAndAppend(set, page);
                    page++;
                } while (hasMore == true);
            }
            catch (Exception e)
            {
                throw e;
            }
        }

        state.CurrentCard = 0;
        state.TotalCards = DownloadSettings.Cards.Count();
    }

    public async Task AuditSets()
    {
        if (AllSets == null) await GetAllSets();

        await Forge.AuditSets(ForgeData, AllSets);
    }

    public async Task AuditCards(string code)
    {
        await Forge.AuditCards(ForgeData ,code, DownloadSettings.RedownloadData);

        //if(matchedCards != null)
        //    DownloadSettings.Cards.AddRange(matchedCards);
    }

    public void RemoveAuditedSet(string code)
    {
        if (ForgeData.ImplementedCards.Count == 0 && ForgeData.MissingCards.Count == 0) return;

        if (ForgeData.ImplementedCards.Count > 0)
            ForgeData.ImplementedCards = ForgeData.ImplementedCards.Where(c => c.Set != code).ToList();

        if (ForgeData.MissingCards.Count > 0)
            ForgeData.MissingCards = ForgeData.MissingCards.Where(c => c.Set != code).ToList();
    }

    private async Task<bool> SearchCardsAndAppend(string set, int page)
    {
        try
        {
            SearchOptions options = new SearchOptions()
                {
                    Sort = SearchOptions.CardSort.Set,
                    Mode = SearchOptions.RollupMode.Prints
                };

            var cards = await Api.Cards.Search($"set:{set}", page, options);

            DownloadSettings.Cards.AddRange(cards.Data);

            return cards.HasMore;
        }
        catch (Exception e)
        {
            throw e;
        }
    }

    public async Task DownloadImages()
    {
        state.IsDownloading = true;

        DownloadSettings.Cards = ForgeData.ImplementedCards;

        _currentSet = DownloadSettings.Cards[0].Set;
        var setPath = CheckDirectory(_currentSet);

        foreach (var card in DownloadSettings.Cards)
        {
            state.CurrentCardName = $"{card.Name} | {card.Set.ToUpper()}";
            state.CurrentCard++;

            if (_currentSet != card.Set) setPath = CheckDirectory(card.Set);

            var saveFormat = ParseFormat();

            if (card.Layout == "transform")
            {
                foreach (var face in card.CardFaces)
                {
                    var cardPath = Path.Combine(setPath, $"{ParseCardName(card, face)}.full.{saveFormat}");

                    if (DownloadSettings.InstantDownload)
                        SaveImage(face.ImageUris, cardPath, card.HighresImage);
                    else
                        await SaveImage(face.ImageUris, cardPath, card.HighresImage);
                }
            }
            else
            {
                var cardPath = Path.Combine(setPath, $"{ParseCardName(card)}.full.{saveFormat}");

                if (DownloadSettings.InstantDownload)
                    SaveImage(card.ImageUris, cardPath, card.HighresImage);
                else
                    await SaveImage(card.ImageUris, cardPath, card.HighresImage);
            }
        }

        state.IsDownloading = false;
        _duplicatePrints.Clear();
        DownloadSettings.Cards.Clear();
        ForgeData.ImplementedCards.Clear();
        ForgeData.MissingCards.Clear();
    }

    private async Task SaveImage(Dictionary<string, Uri> uris, string path, bool highres)
    {
        if (File.Exists(path) && DownloadSettings.IgnoreExisting) return;

        var format = DownloadSettings.PngHighresOnly && DownloadSettings.Format == "png" && !highres ? "border_crop" : DownloadSettings.Format;
        if (uris == null || uris[format] == null) return;

        var data = await Downloader.DownloadImage(uris[format].AbsoluteUri);

        if (DownloadSettings.ConvertToJpg && format == "png")
            data = Image.ConvertToJpg(data, DownloadSettings.OutputQuality);

        await IO.SaveFile(path, data);
    }

    private string CheckDirectory(string scryfallSet)
    {
        var set = ForgeData.MatchedSets.First(s => s.ScryfallCode == scryfallSet).ForgeCode;

        var path = Path.Combine(DownloadSettings.ImagesPath, set);

        if (Directory.Exists(path) && DownloadSettings.RemoveExisting)
            Directory.Delete(path, true);

        IO.CreateDirectory(path);

        _currentSet = scryfallSet;

        return path;
    }

    private string ParseFormat() => (DownloadSettings.Format != "png" || DownloadSettings.ConvertToJpg) ? "jpg" : "png";

    private string ParseCardName(Card card, CardFace? face = null)
    {
        var cardName = face == null ? card.Name : face.Name;

        if (DownloadSettings.Cards.Count(c => c.Name == card.Name && c.Set == card.Set) > 1)
        {
            if (!_duplicatePrints.ContainsKey(card.Set)) _duplicatePrints.Add(card.Set, new List<string>());

            _duplicatePrints[card.Set].Add(cardName);

            var count = _duplicatePrints[card.Set].Count(c => c == cardName);

            cardName = cardName + count;
        }

        return ParsingHelper.ParseCardname(cardName, true);
    }
}
